require "stdlib"

-------------------------------------------------------------------
------------------------ UTILITY FUNCTIONS ------------------------
-------------------------------------------------------------------

function toSUn(L, X)    -- Project a matrix onto SU(N)
  local Y = (X - X:adjoin()) / 2    -- anti-hermitian part
  return (Y - Y:trace() / Nc * L:ColorMatrix(complex(1, 0))):exp()
end

function weak_SUn(L, S)    -- Generate a SU(N) field close to 1
  return toSUn(L, .1 * S:gaussian_ColorMatrix())
end

function weakSingleSUn()
  return toSUnSingle(.1 * qcd.ColorMatrix())    -- need an analog of S:gaussian_ColorMatrix
end

function strong_SUn(L, S)
  local v = weak_SUn(L, S)
  for i = 1, 100 do -- multiply a lot of small SU(n) matrices, then re project
    v = v * weak_SUn(L, S)
  end
  return v:proj(1e-6, 150)
end

function plaquette(U, i, j)   -- U is the gauge field configuration, i = \hat{\mu}, j = \hat{\nu}
  local Ui = U[j + 1]:shift(i, "from_forward")
  local Uj = U[i + 1]:shift(j, "from_forward")
  local Pij = (U[i + 1] * Ui * Uj:adjoin() * U[j + 1]:adjoin()):trace():real()
  return Pij:sum() / (vol * Nc)
end

--[[
Returns the staple field from deleting the link variable in the mu direction
]]
function getStaples(U, mu)
  staples = L:ColorMatrixN(Nc, 0.0)
  for nu = 0, #L - 1 do
    if nu ~= mu then
      local UMu = U[nu + 1]:shift(mu, "from_forward")
      local UNu = U[mu + 1]:shift(nu, "from_forward")
      local UMuNu = U[nu + 1]:shift(mu, "from_forward"):shift(nu, "from_backward")
      local UNegNuMu = U[mu + 1]:shift(nu, "from_backward")
      local UNegNuNu = U[nu + 1]:shift(nu, "from_backward")
      staples = staples + (UMu * UNu:adjoin() * U[nu + 1]:adjoin()
          + UMuNu:adjoin() * UNegNuMu:adjoin() * UNegNuNu)
    end
  end
  return staples
end

-- returns the staple in the mu direction at site (x, y, z, t)
function getStaple(U, mu, x, y, z, t)
  return getStaples(U, mu)[{x, y, z, t}]
end

-- Construct random gauge field
function getRandomColorMatrix(L, S)
  U = {}
  for i = 0, #L - 1 do
    U[i + 1] = toSUn(.3 * S:gaussian_ColorMatrix())
  end
  return U
end

--[[
Show a Nc x Nc color matrix U. Note that this cannot be a lattice field,
it must be an individual matrix.
--]]
function show_color_mat(U)
  local Nc = U:colors()
  for a = 0, Nc-1 do
    for b = 0, Nc-1 do
      local elt = U[{a=a,b=b}]
      printf("%.6f %+.6f\t", elt:real(), elt:imag())
    end
    printf("\n")
  end
end

function computeLocalDeltaS(U, UPrimeMu, mu, x, y, z, t, Nc)
  beta = 5.7
  dU = UPrimeMu[{x, y, z, t}] - U[mu + 1][{x, y, z, t}]
  return (-1) * beta / Nc * (dU * getStaple(U, mu, x, y, z, t)):trace():real()
end

function init_zero_field(L, Nc, U)
  for mu = 0, #L - 1 do
    local A = L:ColorMatrixN(Nc, 0.0)
    U[mu+1] = (A*complex(0,1)):exp()
  end
end

-- Reads an individual real-valued gauge configuration from a text file.
function read_gauge_txt(filename, U, Lx, Lt, Nd, Nc, imag)
  local counter = 0
  local x, y, z, t, mu, a, b
  for line in io.lines(filename) do
    local temp = counter
    local value = tonumber(line)
    b = temp % Nc
    temp = temp - b
    temp = temp / Nc
    a = temp % Nc
    temp = temp - a
    temp = temp / Nc
    x = temp % Lx
    temp = temp - x
    temp = temp / Lx
    y = temp % Lx
    temp = temp - y
    temp = temp / Lx
    z = temp % Lx
    temp = temp - z
    temp = temp / Lx
    t = temp % Lt
    temp = temp - t
    temp = temp / Lt
    mu = temp
    -- if temp >= Nd, this is bad
    -- if temp >= Nd then printf("%d\n", counter) end
    assert (temp < Nd)
    local comp_value
    if imag then
      comp_value = complex(0, value)
    else
      comp_value = complex(value, 0)
    end
    U[mu+1][{x,y,z,t,a=a,b=b}] = U[mu+1][{x,y,z,t,a=a,b=b}] + comp_value
    counter = counter + 1
  end
  return U
end

--[[
Initialize gauge field from HMC run from a text file. Note that for text
input, real and imaginary parts of the data are stored in different
files.
]]
function initGaugeFieldTxt(L, Nc, U, cfgbase, configNum)
  local filename_real = string.format("%s/%s_realconfig%d.txt", cfgbase, cfgbase, configNum)
  local filename_imag = string.format("%s/%s_imagconfig%d.txt", cfgbase, cfgbase, configNum)

  U = {}
  init_zero_field(L, Nc, U)
  printf("Reading from: %s\n", filename_real)
  read_gauge_txt(filename_real, U, L[0], L[3], #L, Nc, U, false)
  printf("Reading from: %s\n", filename_imag)
  read_gauge_txt(filename_imag, U, L[0], L[3], #L, Nc, U, true)
  return U
end

-- Initialize a gauge field from a .h5 file.
function initGaugeFieldHdf5(L, Nc, U, cfgbase, configNum)
  local cfghdf5 = string.format("cfgs/majorana/"..cfgbase.."/"..cfgbase.."_cfg_%d.h5", configNum)
  local cfgbaseh5 = string.format(cfgbase.."/cfg/%d", configNum)
  local hdf5params = { method = "phdf5" }

  local U = {}
  local name = string.format(cfghdf5, i0)
  print(name)
  local h5_reader = qcd.hdf5.Reader(name, hdf5params)
  for mu = 0, #L - 1 do
     U[mu+1] = h5_reader:read(string.format(cfgbaseh5,i0).."/mu"..tostring(mu), {lattice=L})
   end
   return U
end

function initGaugeFieldLime(L, path, cfgbase, configNum)
  local fileName = string.format(path..cfgbase.."/cfgs/"..cfgbase.."_cfg_%d.lime", configNum)
  print(fileName .. "\n")
  reader, rinfo = qcd.qdpc.Reader(L, fileName)
  U, uInfo = reader:ColorMatrix(#L)
  return U
end

-- computes the pion interpolator for a single configuration of gauge field U.
function computePionInterpolator(L, U, vol, m_u, m_d)
  -- Hopping parameters
  kappa_u = 1 / (2 * m_u + 8)
  kappa_d = 1 / (2 * m_d + 8)
  kappa = .071    -- generic hopping parameter

  -- Construct propagators. Need the inverse of the Dirac operator, so will
     -- use solvers, which the Clover object contains.
  c_sw = 1.0      -- Sheikholeslami-Wohlert coefficient for clover term
  bc = {1, 1, 1, -1}    -- periodic in space, antiperiodic in time

  CL_u = qcd.Clover(U, kappa_u, c_sw, bc)
  solveU = CL_u:solver(1e-10, 1000, 1e-25, 2000)

  CL_d = qcd.Clover(U, kappa_d, c_sw, bc)
  solveD = CL_d:solver(1e-10, 1000, 1e-25, 2000)

  src = L:DiracPropagator()
  Nc = src:colors()
  for ic = 0, Nc - 1 do -- loop over color indices
    for is = 0, qcd.Ns - 1 do  -- loop over spinor indices
      local dv = L:DiracFermion()
      dv[{0, 0, 0, 0, c = ic, d = is}] = complex(1, 0)
      src[{c = ic, d = is}] = dv
    end
  end

  uProp = solveU(src)  -- D_u(n|m)^-1
  dProp = solveD(src)  -- D_d(n|m)^-1

  corr = (-1) * (uProp * dProp:conj()):spintrace():trace()
  corr_normalized = corr / math.sqrt(vol)

  -- sum this lattice field on the time slice n_t. Gives back a vector
  p_proj = corr_normalized:sum(L:MultiSet(L[3], L:pcoord(3)))
  return p_proj
end

--[[
Run get_cfgs.py first on folder with all gauge configurations
to generate a text file at path..base.."_config_ids.txt"
]]
function getCfgIds(path, base)
  cfgIds = {}
  fname = path..base.."/config_ids.txt"
  printf("Reading configuration numbers from %s", fname)
  i = 0
  for line in io.lines(fname) do
    cfgIds[i] = tonumber(line)
    i = i + 1
  end
  return cfgIds
end

------------------------------------------------------------------
-------------------------- BEGIN SCRIPT --------------------------
------------------------------------------------------------------

-- Set parameters
--[[
L = qcd.lattice{8, 8, 8, 8}
cfgbase = "su3_w_b5.70_N20_skip10_therm100_8_8_8_8"    -- folder to find configs in
nCfgs = 20  -- Number of configurations to run with
beta = 5.7  -- Get it from the file name
]]
Nc = 3    -- qcd.Nc

L = qcd.lattice{16, 16, 16, 48}
path = "/data/d10b/ensembles/isoClover/"
-- path = "/Users/poare/lqcd/pion_mass/"
cfgbase = "cl3_16_48_b6p1_m0p2450"
beta = 6.1
mq = .2450

volume = 1    -- spatial volume
for i = 0, #L - 2 do
  volume = volume * L[i]
end
hypervolume = volume * L[3]

-- random generator used to create gauge field
r = { }
do
  r.x = os.random()
  local x = L:Int(r.x)
  for i = 0, #L - 1 do
    r[i+1] = os.random()
    x = x * L[i] + L:pcoord(i) * r[i+1]
  end
  r.f = os.random()
  S = L:RandomState(r.f, x)
end

-- Initialize output file
rand = math.random(10000)
folder = "/home/poare/lqcd/pion_mass/test_pion_mass_output"
filename = string.format("%s/%s_output%d.txt", folder, cfgbase, rand)
file = io.open(filename, "a")
file:write(string.format("Sampled configurations on a (%d, %d, %d, %d) lattice using beta = %f.\n",
        L[0], L[1], L[2], L[3], beta))

C = {}    -- C is an array, C[n_t] is the correlator projected to 0 momentum on the n_t time slice
for n_t = 0, L[3] - 1 do
  C[n_t] = 0
end

cfgIdPath = '/home/poare/lqcd/pion_mass/cfgIds/'
-- cfgIdPath = '/Users/poare/lqcd/pion_mass/cfgIds/'
cfgIds = getCfgIds(cfgIdPath, cfgbase)
nCfgs = 0

for _, cfgIdx in ipairs(cfgIds) do
  U = initGaugeFieldLime(L, path, cfgbase, cfgIdx)
  msg = string.format("%d|", cfgIdx)
  interpolator = computePionInterpolator(L, U, volume, mq, mq)
  for n_t = 0, L[3] - 1 do
    C[n_t] = C[n_t] + interpolator[n_t]
    -- each msg of the form cfgId|a1+ib1 a2+ib2 a3+ib3 ..., for interpolator = a+ib
    msg = msg..string.format("%e+i(%e) ", interpolator[n_t]:real(), interpolator[n_t]:imag())
  end
  msg = msg.."\n"
  -- printf("Configuration %d evaluated.\n", cfgIdx)
  printf(msg)
  file:write(msg)
  nCfgs = nCfgs + 1
end

printf("Evaluated %d configurations.\n", nCfgs)

--[[
CAvg = {}
for n_t = 0, L[3] - 1 do
  CAvg[n_t] = C[n_t] / nCfgs
end

file:write("-\n") -- break the output
printf("n_t | C[n_t]\n")
file:write("n_t | C[n_t]\n")
for n_t = 0, L[3] - 1 do
  message = string.format("%d | %e + i(%e)\n", n_t, CAvg[n_t]:real(), CAvg[n_t]:imag())
  printf(message)
  file:write(message)
end
]]

file:close()
printf("File written to: %s\n", filename)
