require "stdlib"

-------------------------------------------------------------------
------------------------ UTILITY FUNCTIONS ------------------------
-------------------------------------------------------------------

--[[
Show a Nc x Nc color matrix U. Note that this cannot be a lattice field,
it must be an individual matrix.
--]]
function show_color_mat(U)
  local Nc = U:colors()
  for a = 0, Nc-1 do
    for b = 0, Nc-1 do
      local elt = U[{a=a,b=b}]
      printf("%.6f %+.6f\t", elt:real(), elt:imag())
    end
    printf("\n")
  end
end

function init_zero_field(L, Nc, U)
  for mu = 0, #L - 1 do
    local A = L:ColorMatrixN(Nc, 0.0)
    U[mu+1] = (A*complex(0,1)):exp()
  end
end

-- Initialize a gauge field from a .h5 file.
function initGaugeFieldHdf5(L, Nc, U, cfgbase, configNum)
  local cfghdf5 = string.format("cfgs/majorana/"..cfgbase.."/"..cfgbase.."_cfg_%d.h5", configNum)
  local cfgbaseh5 = string.format(cfgbase.."/cfg/%d", configNum)
  local hdf5params = { method = "phdf5" }

  local U = {}
  local name = string.format(cfghdf5, i0)
  print(name)
  local h5_reader = qcd.hdf5.Reader(name, hdf5params)
  for mu = 0, #L - 1 do
     U[mu+1] = h5_reader:read(string.format(cfgbaseh5,i0).."/mu"..tostring(mu), {lattice=L})
   end
   return U
end

function initGaugeFieldLime(L, path, cfgbase, configNum)
  local fileName = string.format(path..cfgbase.."/cfgs/"..cfgbase.."_cfg_%d.lime", configNum)
  print(fileName .. "\n")
  reader, rinfo = qcd.qdpc.Reader(L, fileName)
  U, uInfo = reader:ColorMatrix(#L)
  return U
end

-- computes the pion interpolator for a single configuration of gauge field U.
function computePionInterpolator(L, U, vol, m_u, m_d, L_mom)
  -- Hopping parameters
  kappa_u = 1 / (2 * m_u + 8)
  kappa_d = 1 / (2 * m_d + 8)

  -- Construct propagators. Need the inverse of the Dirac operator, so will
     -- use solvers, which the Clover object contains.
  c_sw = 1.0      -- SW coefficient for clover term
  bc = {1, 1, 1, -1}    -- periodic in space, antiperiodic in time

  CL_u = qcd.Clover(U, kappa_u, c_sw, bc)
  solveU = CL_u:solver(1e-10, 1000, 1e-25, 2000)

  -- CL_d = qcd.Clover(U, kappa_d, c_sw, bc)
  -- solveD = CL_d:solver(1e-10, 1000, 1e-25, 2000)

  src = L:DiracPropagator()
  Nc = src:colors()
  for ic = 0, Nc - 1 do -- loop over color indices
    for is = 0, qcd.Ns - 1 do  -- loop over spinor indices
      local dv = L:DiracFermion()
      dv[{0, 0, 0, 0, c = ic, d = is}] = complex(1, 0)
      src[{c = ic, d = is}] = dv
    end
  end

  uProp = solveU(src)  -- D_u(n|m)^-1
  -- dProp = solveD(src)  -- D_d(n|m)^-1

  CL_u:close()
  -- CL_d:close()

  -- check if transpose() does spintranspose() as well as color transpose... probs just color transpose.
  -- qcd.dot(prop1, prop2) should take a matrix dot product of A conjugate times B, so the contraction A_{ab}^* B_{ab}
  -- corr = (-1) * qcd.dot(uProp, uProp)
  -- corr = (-1) * qcd.dot(uProp:spintranspose():transpose(), uProp)
  -- corr_normalized = corr / math.sqrt(vol)
  --
  -- -- sum this lattice field on the time slice n_t. Gives back a vector
  -- p_proj = corr_normalized:sum(L:MultiSet(L[3], L:pcoord(3)))
  -- return p_proj

  local uPropAnti = gamma{mu = 5} * uProp * gamma{mu = 5}
  local twopt = (uProp * gamma{mu = 5} * uPropAnti * gamma{mu = 5}):trace()

  -- This line should do the same as the gathering command, but try each out.
  -- local twopt_proj = twopt:sum(L:MultiSet(L[3], L:pcoord(3)))
  local mom_proj = qcd.gather(L_mom, L, {L:pcoord(#L - 1)})  -- Gather all sites with same t coord
  twopt_proj = mom_proj:add(twopt)  -- project two point

  return twopt_proj
end

--[[ This function returns a projector object. This is a vector of size L[3] whose
  n_t th timeslice is equal to the spatial sum of L[x, y, z, n_t]. Should determine
  how to implement this with parallel indices later.

  Can do this in one line with x:sum(L:MultiSet(L[3], L:pcoord(3)))
]]
function getTimesliceProjector(correlator, L)
  -- p_proj = corr_normalized:sum(L:MultiSet(L[3], L:pcoord(3)))
  p_proj = vector.int(L[3])    -- vector of zeros of size n_t
  for n_t = 0, L[3] - 1 do
    for x = 0, L[0] - 1 do
      for y = 0, L[1] -  1 do
        for z = 0, L[2] - 1 do
          p_proj[n_t] = p_proj[n_t] + correlator[{x, y, z, n_t}]
        end
      end
    end
  end
  return p_proj
end

--[[
Run get_cfgs.py first on folder with all gauge configurations
to generate a text file at path..base.."_config_ids.txt"
]]
function getCfgIds(path, base)
  cfgIds = {}
  fname = path..base.."/config_ids.txt"
  printf("Reading configuration numbers from %s", fname)
  i = 0
  for line in io.lines(fname) do
    cfgIds[i] = tonumber(line)
    i = i + 1
  end
  return cfgIds
end

------------------------------------------------------------------
-------------------------- BEGIN SCRIPT --------------------------
------------------------------------------------------------------

-- Set parameters
Nc = 3    -- qcd.Nc

Lx = 16
Lt = 48
L = qcd.lattice{Lx, Lx, Lx, Lt}
L_mom = qcd.lattice{Lt}
-- L = qcd.lattice{32, 32, 32, 48}
path = "/data/d10b/ensembles/isoClover/"    -- path to gauge field configs
-- path = "/data/d10b/ensembles/quenched/su3_24_48_b6p10050/cfgs_gf"
cfgbase = "cl3_16_48_b6p1_m0p2450"
-- cfgbase = "cl3_32_48_b6p1_m0p2450"
lqcd_dir = "/home/poare/"    -- specify what the file path to lqcd is
-- beta = 6.10050
beta = 6.1
mq = .2450

volume = 1    -- spatial volume
for i = 0, #L - 2 do
  volume = volume * L[i]
end
hypervolume = volume * L[3]

-- random generator used to create gauge field
r = { }
do
  r.x = os.random()
  local x = L:Int(r.x)
  for i = 0, #L - 1 do
    r[i+1] = os.random()
    x = x * L[i] + L:pcoord(i) * r[i+1]
  end
  r.f = os.random()
  S = L:RandomState(r.f, x)
end

-- Initialize output file
math.randomseed(os.time())
rand = math.random(10000)
folder = lqcd_dir.."lqcd/pion_mass/output"
-- filename = string.format("%s/%s_output%d.txt", folder, cfgbase, rand)
filename = string.format("%s/%s_output%d.h5", folder, cfgbase, rand)
printf("OUTPUT FILE WILL WRITE TO: %s\n", filename)

-- writer = io.open(filename, "a")
-- file:write(string.format("Sampled configurations on a (%d, %d, %d, %d) lattice using beta = %f.\n",
--         L[0], L[1], L[2], L[3], beta))

local hdf5params = { method = "phdf5" }
writer = qcd.hdf5.Writer(filename, hdf5params)

-- If there is an input cfgnum, then use that as cfgIdx
cfgIds = {}
if cfgnum then
  cfgIds[0] = cfgnum
else
  cfgIdPath = lqcd_dir.."lqcd/pion_mass/cfgIds/"
  cfgIds = getCfgIds(cfgIdPath, cfgbase)
end

-- Loop over gauge field configurations.
nCfgs = 0
for _, cfgIdx in ipairs(cfgIds) do
  U = initGaugeFieldLime(L, path, cfgbase, cfgIdx)
  msg = string.format("%d|", cfgIdx)
  interpolator = computePionInterpolator(L, U, volume, mq, mq, L_mom)
  print("Here\n")
  print(interpolator[{0}])
  print("Finished\n")

  -- Write message and store data. Each msg of the form cfgId|a1+ib1 a2+ib2 a3+ib3 ..., for interpolator = a+ib
  for n_t = 0, L[3] - 1 do
    msg = msg..string.format("%e+i(%e) ", interpolator[n_t]:real(), interpolator[n_t]:imag())
  end
  msg = msg.."\n"
  printf(msg)
  -- file:write(msg)
  path = string.format("twopt/%d", cfgIdx)
  writer:write(path, interpolator)
  nCfgs = nCfgs + 1
end

if nCfgs > 1 then
  printf("Evaluated %d configurations.\n", nCfgs)
end

writer:close()
