#!/usr/bin/env qlua

require "stdlib"
require "lib/clover_ferm"
require "lib/fermion"
require "lib/propagator"

-- This script calculates the connected diagrams to the qq diquark

-- This also requires some gauge fields.  We should make sure we have some of those.

-- read in the gauge fields

Nc=2
beta=2.05
Lx=8
Lt=16

-- number of sources that we want per direction
Nx=2
Nt=4

-- distance between sources in each direction
Dx=Lx/Nx
Dt=Lt/Nt

kappa=0.198
u0=1000
csw=1e-10
bcs={1,1,1,-1}
eps=1e-12
max_iter=1000
adj=true

L = qcd.lattice{Lx,Lx,Lx,Lt}

configNum=114

local cfgbase = string.format("su%d_cl_b%.2f_k%.3f_u%.3f_%d_%d_%d_%d", Nc, beta, kappa, u0, Lx, Lx, Lx, Lt)
local cfghdf5 = string.format("cfgs/majorana/"..cfgbase.."/"..cfgbase.."_cfg_%d.h5", configNum)
local cfgbaseh5 = string.format(cfgbase.."/cfg/%d", configNum)
local hdf5params = { method = "phdf5" }

print("preparing to create files for writing")
-- we will make a separate folder for each gamma matrix
local filename
local files = {}
for i = 0, qcd.Ns * qcd.Ns - 1 do
   filename = string.format("meas/diquarks/gamma=%d/diquark-beta-%.2f-kappa-%.2f-config-%d", i, beta, kappa, configNum)
   files[i]=io.open(filename, "w")
end
print("output files created successfully")

local U = {}
local name = string.format(cfghdf5, i0)
print(name)
local h5_reader = qcd.hdf5.Reader(name, hdf5params)
for mu = 0, #L - 1 do
   U[mu+1] = h5_reader:read(string.format(cfgbaseh5,i0).."/mu"..tostring(mu), {lattice=L})
end


-- number of noise vectors per timeslice

if _quda ~= nil then
   print("Initializing QUDA")
   require 'scripts/quda'
   qcd.quda.init(L)
   print("QUDA initialized")
end

if _quda ~= nil then
   local ferm = clover_ferm.quda_4d_nc3(kappa, csw, bcs)
   solve = propagator.make_from_ferm(ferm, eps, max_iter, adj)
else
   local ferm = clover_ferm.cpu_4d_nc3(kappa, csw, bcs)
   solve = propagator.make_from_ferm(ferm, eps, max_iter, adj)
end

-- connected piece
-- code below shamelessly stolen from QLua tutorials

solver=solve.propagator(U)

--src = L:DiracPropagator()
q_prop = L:DiracPropagator()
Nc = q_prop:colors()
local w = L:Real(1)
diquarks = {}
for i = 0, qcd.Ns * qcd.Ns - 1 do
  diquarks[i]={}
  for t = 0, Lt - 1 do
    diquarks[i][t]=0
  end
end
for x = 0, Lx - Dx, Dx do
  for y = 0, Lx - Dx, Dx do
    for z = 0, Lx - Dx, Dx do
      for tau = 0, Lt - Dt, Dt do
        for ic = 0, Nc - 1 do
          for is = 0, qcd.Ns - 1 do
            local dv = L:DiracFermion()
            dv[{x,y,z,tau,c=ic,d=is}] = complex(1,0)
            q_prop[{c=ic,d=is}] = solver(dv)
            --src[{c=ic,d=is}] = dv
          end
        end

        --q_prop = solve.propagator(U)(src)

        -- Note that this has different indexing from pions.qlua
        qq = {}
        for i = 0, qcd.Ns * qcd.Ns - 1 do
          qq[i] = (q_prop:transpose() * gamma{n=i} * q_prop * gamma{n=i}):trace()
          local prop = (qq[i] * w):sum(L:MultiSet(L[3], L:pcoord(3)))
          for t = 0, L[3] - 1 do
            diquarks[i][t] = diquarks[i][t] + prop[(t+tau)%Lt]:real()
          end
        end

      end
    end
  end
end




--local prop = (qq[11] * w):sum(L:MultiSet(L[3], L:pcoord(3)))
--for t = 0, L[3]-1 do
--  file:write(prop[t]:real().."\n")
--end

-- disconnected piece
-- doesn't need to be computed for diquark :)

-- print out the connected and disconnected pieces

for i = 0, qcd.Ns * qcd.Ns - 1 do
  for t = 0, L[3]-1 do
    files[i]:write(diquarks[i][t].."\n")
    if i == 15 then
      --print(prop[t]:real().." "..prop[t]:imag())
      --print(diquarks[i][t])
    end
  end
  files[i]:close()
end
