require "stdlib"

L = qcd.lattice{4, 4, 4, 8}
volume = 1
for i = 0, #L - 1 do
  volume = volume * L[i]
end
Nc = 3    -- qcd.Nc

function toSUn(L, X)    -- Project a matrix onto SU(N)
  local Y = (X - X:adjoin()) / 2    -- anti-hermitian part
  return (Y - Y:trace() / Nc * L:ColorMatrix(complex(1, 0))):exp()
end

function weak_SUn(L, S)    -- Generate a SU(N) field close to 1
  return toSUn(L, .1 * S:gaussian_ColorMatrix())
end

-- TODO figure out how to generate random color matrices
function weakSingleSUn()
  return toSUnSingle(.1 * qcd.ColorMatrix())    -- need an analog of S:gaussian_ColorMatrix
end

function strong_SUn(L, S)
  local v = weak_SUn(L, S)
  for i = 1, 100 do -- multiply a lot of small SU(n) matrices, then re project
    v = v * weak_SUn(L, S)
  end
  return v:proj(1e-6, 150)
end

function plaquette(U, i, j)   -- U is the gauge field configuration, i = \hat{\mu}, j = \hat{\nu}
  local Ui = U[j + 1]:shift(i, "from_forward")
  local Uj = U[i + 1]:shift(j, "from_forward")
  local Pij = (U[i + 1] * Ui * Uj:adjoin() * U[j + 1]:adjoin()):trace():real()
  return Pij:sum() / (vol * Nc)
end

--[[ TODO what is the most efficient way to do this?
Returns the staple field from deleting the link variable in the mu direction
]]
function getStaples(U, mu)
  staples = L:ColorMatrixN(Nc, 0.0)
  for nu = 0, #L - 1 do
    if nu ~= mu then
      local UMu = U[nu + 1]:shift(mu, "from_forward")
      local UNu = U[mu + 1]:shift(nu, "from_forward")
      local UMuNu = U[nu + 1]:shift(mu, "from_forward"):shift(nu, "from_backward")
      local UNegNuMu = U[mu + 1]:shift(nu, "from_backward")
      local UNegNuNu = U[nu + 1]:shift(nu, "from_backward")
      staples = staples + (UMu * UNu:adjoin() * U[nu + 1]:adjoin()
          + UMuNu:adjoin() * UNegNuMu:adjoin() * UNegNuNu)
    end
  end
  return staples
end

-- returns the staple in the mu direction at site (x, y, z, t)
function getStaple(U, mu, x, y, z, t)
  return getStaples(U, mu)[{x, y, z, t}]
end

-- random generator used to create gauge field
r = { }
do
  r.x = os.random()
  local x = L:Int(r.x)
  for i = 0, #L - 1 do
    r[i+1] = os.random()
    x = x * L[i] + L:pcoord(i) * r[i+1]
  end
  r.f = os.random()
  S = L:RandomState(r.f, x)
end

-- Construct random gauge field
function getRandomColorMatrix(L, S)
  U = {}
  for i = 0, #L - 1 do
    U[i + 1] = toSUn(.3 * S:gaussian_ColorMatrix())
  end
  return U
end

function show_color_mat(U)
  local Nc = U:colors()
  for a = 0, Nc-1 do
    for b = 0, Nc-1 do
      local elt = U[{a=a,b=b}]
      printf("%.6f %+.6f\t", elt:real(), elt:imag())
    end
    printf("\n")
  end
end

function computeLocalDeltaS(U, UPrimeMu, mu, x, y, z, t, Nc)
  beta = 1    -- TODO what to do for beta? beta = 2N / g^2
  dU = UPrimeMu[{x, y, z, t}] - U[mu + 1][{x, y, z, t}]
  return (-1) * beta / Nc * (dU * getStaple(U, mu, x, y, z, t)):trace():real()
end

function init_zero_field(L, Nc, U)
  for mu = 0, #L - 1 do
    local A = L:ColorMatrixN(Nc, 0.0)
    U[mu+1] = (A*complex(0,1)):exp()
  end
end

-- Initialize gauge field from HMC run.
function initGaugeField(L, Nc, U)
  -- init_zero_field(L, Nc, U)
  -- TODO initialize field
  -- local cfgbase = string.format("su%d_cl_b%.2f_k%.4f_u%.3f_%d_%d_%d_%d", Nc, beta, kappa, u0, Lx, Lx, Lx, Lt)
  local configNum = 5
  local i0 = 1000    -- what is this?
  local cfgbase = "test_configs"
  -- local cfghdf5 = string.format("~/lqcd/configs/"..cfgbase.."/"..cfgbase.."_cfg_%d.h5", configNum)
  -- local cfgbaseh5 = string.format(cfgbase.."/cfg/%d", configNum)
  local hdf5params = { method = "phdf5" }

  local U = {}
  -- local name = string.format(cfghdf5, i0)
  local name = string.format("configs/test_configs.hdf5")
  print(name)
  local h5_reader = qcd.hdf5.Reader(name, hdf5params)
  h5_reader:read("configs")


  for mu = 0, #L - 1 do
     U[mu+1] = h5_reader:read(string.format(cfgbaseh5,i0).."/mu"..tostring(mu), {lattice=L})
  end
end

-- h5_reader = qcd.hdf5.Reader('~/lqcd/configs/test_configs.hdf5', {method = "phdf5"})
-- local h5_reader = qcd.hdf5.Reader('test_configs.hdf5', {method = "phdf5"})

U = {}
initGaugeField(L, Nc, U)

-- Number of links in t dimension to compute Wilson loop
n_t = 4

-- computes the pion interpolator for a single configuration of gauge field U.
function computePionInterpolator(L, U)
  -- Hopping parameters
  m_u = 2   -- in MeV-- what units should I use here?
  m_d = 4.8
  kappa_u = 1 / (2 * m_u + 8)
  kappa_d = 1 / (2 * m_d + 8)
  kappa = .071    -- generic hopping parameter

  -- Construct propagators. Need the inverse of the Dirac operator, so will
     -- use solvers, which the Clover object contains.
  c_sw = 1.0      -- Sheikholeslami-Wohlert coefficient for clover term
  bc = {1, 1, 1, -1}    -- periodic in space, antiperiodic in time

  n_t = 4

  CL_u = qcd.Clover(U, kappa_u, c_sw, bc)
  solveU = CL_u:solver(1e-10, 1000, 1e-25, 2000)

  CL_d = qcd.Clover(U, kappa_d, c_sw, bc)
  solveD = CL_d:solver(1e-10, 1000, 1e-25, 2000)

  -- TODO figure out how to put a sink at {0, 0, 0, n_t}
  src = L:DiracPropagator()
  Nc = src:colors()
  for ic = 0, Nc - 1 do -- loop over color indices
    for is = 0, qcd.Ns - 1 do  -- loop over spinor indices
      local dv = L:DiracFermion()
      dv[{0, 0, 0, 0, c = ic, d = is}] = complex(1, 0)
      dv[{0, 0, 0, n_t, c = ic, d = is}] = complex(1, 0)    -- TODO is this right?
      src[{c = ic, d = is}] = dv
    end
  end

  uProp = solveU(src)  -- D_u(n|m)^-1
  dProp = solveD(src)  -- D_d(n^m)^-1

  return (-1) * (uProp * dProp:conj()):spintrace():trace():sum()
end

C = 0    -- sum up value of <...> for all gauge field configs
nItr = 10  -- 100
nSweep = 10    -- how many times to update each lattice site per sweep
nMeasured = 0
beta = 1  -- QCD coupling, TODO
for i = 0, nItr do
  for mu = 0, #L - 1 do
    -- initialize weak color matrix field
    --[[
    X = weak_SUn(L, S)    -- Random color matrix field
    UPrimeMu = U[mu + 1] * X    -- evaluated at every lattice point
    --]]
    for x = 0, L[0] - 1 do
      for y = 0, L[1] - 1 do
        for z = 0, L[2] - 1 do
          for t = 0, L[3] - 1 do
            -- screen the update to see if we should keep it
            local A = getStaple(U, mu, x, y, z, t)
            local X = weak_SUn(L, S)
            --[[ TODO: how do you generate a single color matrix and not an
            entire field of matrices? Right now I'm generating X as a color matrix
            field and picking its elements, it seems very inefficient though. ]]
            for k = 0, nSweep do
              --literally just pick a matrix out of the matrix field
              local r = math.random()
              if k < L[0] then coord = {k, 0, 0, 0} else coord = {0, 0, 0, k - L[0] + 1} end
              local X1 = X[coord]
              local U1 = U[mu + 1][{x, y, z, t}]
              local UPrimeMu = X1 * U1
              local dU = UPrimeMu - U1
              local dS = (-1) * beta / Nc * (dU * A):trace():real()

              if r < math.exp(dS) then
                U[mu + 1][{x, y, z, t}] = UPrimeMu
              end
            end
            --[[
            for k = 0, nSweep do
              r = math.random()
              dS = computeLocalDeltaS(U, UPrimeMu, mu, x, y, z, t, Nc)
              if dS < r then
                U[mu + 1][{x, y, z, t}] = UPrimeMu[{x, y, z, t}]
              end
            end
            --]]
          end
        end
      end
    end
    -- change placement based on how often we want to measure the configuration.
    -- at some point can use autocorrelation to determine if we've swept enough.
    nMeasured = nMeasured + 1
    C = C + computePionInterpolator(L, U)
    printf("Average C is: %s\n", tostring(C / nMeasured))
  end
end

--C = C + computeInterpolator(L, U)
if nMeasured == 0 then nMeasured = 1 end
CAvg = C / nMeasured

printf("Interpolator evaluates to: %s\n", tostring(CAvg))
