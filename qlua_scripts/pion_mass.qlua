require "stdlib"

-------------------------------------------------------------------
------------------------ UTILITY FUNCTIONS ------------------------
-------------------------------------------------------------------

function toSUn(L, X)    -- Project a matrix onto SU(N)
  local Y = (X - X:adjoin()) / 2    -- anti-hermitian part
  return (Y - Y:trace() / Nc * L:ColorMatrix(complex(1, 0))):exp()
end

function weak_SUn(L, S)    -- Generate a SU(N) field close to 1
  return toSUn(L, .1 * S:gaussian_ColorMatrix())
end

function weakSingleSUn()
  return toSUnSingle(.1 * qcd.ColorMatrix())    -- need an analog of S:gaussian_ColorMatrix
end

function strong_SUn(L, S)
  local v = weak_SUn(L, S)
  for i = 1, 100 do -- multiply a lot of small SU(n) matrices, then re project
    v = v * weak_SUn(L, S)
  end
  return v:proj(1e-6, 150)
end

function plaquette(U, i, j)   -- U is the gauge field configuration, i = \hat{\mu}, j = \hat{\nu}
  local Ui = U[j + 1]:shift(i, "from_forward")
  local Uj = U[i + 1]:shift(j, "from_forward")
  local Pij = (U[i + 1] * Ui * Uj:adjoin() * U[j + 1]:adjoin()):trace():real()
  return Pij:sum() / (vol * Nc)
end

--[[ TODO what is the most efficient way to do this?
Returns the staple field from deleting the link variable in the mu direction
]]
function getStaples(U, mu)
  staples = L:ColorMatrixN(Nc, 0.0)
  for nu = 0, #L - 1 do
    if nu ~= mu then
      local UMu = U[nu + 1]:shift(mu, "from_forward")
      local UNu = U[mu + 1]:shift(nu, "from_forward")
      local UMuNu = U[nu + 1]:shift(mu, "from_forward"):shift(nu, "from_backward")
      local UNegNuMu = U[mu + 1]:shift(nu, "from_backward")
      local UNegNuNu = U[nu + 1]:shift(nu, "from_backward")
      staples = staples + (UMu * UNu:adjoin() * U[nu + 1]:adjoin()
          + UMuNu:adjoin() * UNegNuMu:adjoin() * UNegNuNu)
    end
  end
  return staples
end

-- returns the staple in the mu direction at site (x, y, z, t)
function getStaple(U, mu, x, y, z, t)
  return getStaples(U, mu)[{x, y, z, t}]
end

-- Construct random gauge field
function getRandomColorMatrix(L, S)
  U = {}
  for i = 0, #L - 1 do
    U[i + 1] = toSUn(.3 * S:gaussian_ColorMatrix())
  end
  return U
end

function show_color_mat(U)
  local Nc = U:colors()
  for a = 0, Nc-1 do
    for b = 0, Nc-1 do
      local elt = U[{a=a,b=b}]
      printf("%.6f %+.6f\t", elt:real(), elt:imag())
    end
    printf("\n")
  end
end

function computeLocalDeltaS(U, UPrimeMu, mu, x, y, z, t, Nc)
  beta = 5.7
  dU = UPrimeMu[{x, y, z, t}] - U[mu + 1][{x, y, z, t}]
  return (-1) * beta / Nc * (dU * getStaple(U, mu, x, y, z, t)):trace():real()
end

function init_zero_field(L, Nc, U)
  for mu = 0, #L - 1 do
    local A = L:ColorMatrixN(Nc, 0.0)
    U[mu+1] = (A*complex(0,1)):exp()
  end
end

function read_gauge(filename, Lx, Lt, Nd, Nc, U, imag)
  local counter = 0
  local x, y, z, t, mu, a, b
  for line in io.lines(filename) do
    local temp = counter
    local value = tonumber(line)
    b = temp % Nc
    temp = temp - b
    temp = temp / Nc
    a = temp % Nc
    temp = temp - a
    temp = temp / Nc
    x = temp % Lx
    temp = temp - x
    temp = temp / Lx
    y = temp % Lx
    temp = temp - y
    temp = temp / Lx
    z = temp % Lx
    temp = temp - z
    temp = temp / Lx
    t = temp % Lt
    temp = temp - t
    temp = temp / Lt
    mu = temp
    -- if temp >= Nd, this is bad
    -- if temp >= Nd then printf("%d\n", counter) end
    assert (temp < Nd)
    local comp_value
    if imag then
      comp_value = complex(0, value)
    else
      comp_value = complex(value, 0)
    end
    U[mu+1][{x,y,z,t,a=a,b=b}] = U[mu+1][{x,y,z,t,a=a,b=b}] + comp_value
    counter = counter + 1
  end
end

-- Initialize gauge field from HMC run.
function initGaugeField(L, Nc, U, cfgbase, configNum)
  local filename_real = string.format("%s/%s_realconfig%d.txt", cfgbase, cfgbase, configNum)
  local filename_imag = string.format("%s/%s_imagconfig%d.txt", cfgbase, cfgbase, configNum)

  init_zero_field(L, Nc, U)
  printf("Reading from: %s\n", filename_real)
  read_gauge(filename_real, L[0], L[3], #L, Nc, U, false)
  printf("Reading from: %s\n", filename_imag)
  read_gauge(filename_imag, L[0], L[3], #L, Nc, U, true)
end

-- computes the pion interpolator for a single configuration of gauge field U.
function computePionInterpolator(L, U, vol)
  -- Hopping parameters
  m_u = 2   -- in MeV-- what units should I use here?
  m_d = 4.8
  kappa_u = 1 / (2 * m_u + 8)
  kappa_d = 1 / (2 * m_d + 8)
  kappa = .071    -- generic hopping parameter

  -- Construct propagators. Need the inverse of the Dirac operator, so will
     -- use solvers, which the Clover object contains.
  c_sw = 1.0      -- Sheikholeslami-Wohlert coefficient for clover term
  bc = {1, 1, 1, -1}    -- periodic in space, antiperiodic in time

  CL_u = qcd.Clover(U, kappa_u, c_sw, bc)
  solveU = CL_u:solver(1e-10, 1000, 1e-25, 2000)

  CL_d = qcd.Clover(U, kappa_d, c_sw, bc)
  solveD = CL_d:solver(1e-10, 1000, 1e-25, 2000)

  src = L:DiracPropagator()
  Nc = src:colors()
  for ic = 0, Nc - 1 do -- loop over color indices
    for is = 0, qcd.Ns - 1 do  -- loop over spinor indices
      local dv = L:DiracFermion()
      dv[{0, 0, 0, 0, c = ic, d = is}] = complex(1, 0)
      src[{c = ic, d = is}] = dv
    end
  end

  uProp = solveU(src)  -- D_u(n|m)^-1
  dProp = solveD(src)  -- D_d(n|m)^-1

  corr = (-1) * (uProp * dProp:conj()):spintrace():trace()
  corr_normalized = corr / math.sqrt(vol)

  -- sum this lattice field on the time slice n_t. Gives back a vector
  p_proj = corr_normalized:sum(L:MultiSet(L[3], L:pcoord(3)))
  return p_proj
end

------------------------------------------------------------------
-------------------------- BEGIN SCRIPT --------------------------
------------------------------------------------------------------

L = qcd.lattice{4, 4, 4, 8}
volume = 1    -- spatial volume
for i = 0, #L - 2 do
  volume = volume * L[i]
end
hypervolume = volume * L[3]

Nc = 3    -- qcd.Nc

-- random generator used to create gauge field
r = { }
do
  r.x = os.random()
  local x = L:Int(r.x)
  for i = 0, #L - 1 do
    r[i+1] = os.random()
    x = x * L[i] + L:pcoord(i) * r[i+1]
  end
  r.f = os.random()
  S = L:RandomState(r.f, x)
end

C = {}    -- C is an array, C[n_t] is the correlator projected to 0 momentum on the n_t time slice
for n_t = 0, L[3] - 1 do
  C[n_t] = 0
end
cfgbase = "su3_w_b5.70_N5_skip10_therm100_4_4_4_8"    -- folder to find configs in
nCfgs = 5  -- Number of configurations to run with
beta = 5.7  -- Get it from the file name
for cfgIdx = 0, nCfgs - 1 do    -- compute correlator from each configuration
  U = {}
  initGaugeField(L, Nc, U, cfgbase, cfgIdx)
  interpolator = computePionInterpolator(L, U, volume)
  for n_t = 0, L[3] - 1 do
    C[n_t] = C[n_t] + interpolator[n_t]
  end
  printf("Configuration %d evaluated.\n", cfgIdx)
end

CAvg = {}
for n_t = 0, L[3] - 1 do
  CAvg[n_t] = C[n_t] / nCfgs
end

folder = "test_pion_mass_output"
filename = string.format("%s/%s_output.txt", folder, cfgbase)
file = io.open(filename, "a")
file:write(string.format("Sampled on %d configurations on a (%d, %d, %d, %d) lattice using beta = %f.\n",
        nCfgs, L[0], L[1], L[2], L[3], beta))
printf("n_t | C[n_t]\n")
file:write("n_t | C[n_t]\n")

for n_t = 0, L[3] - 1 do
  message = string.format("%d | %f + i(%f)\n", n_t, CAvg[n_t]:real(), CAvg[n_t]:imag())
  printf(message)
  file:write(message)
end

file:close()
printf("File written to: %s\n", filename)
