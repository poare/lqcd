require "stdlib"

-------------------------------------------------------------------
------------------------ UTILITY FUNCTIONS ------------------------
-------------------------------------------------------------------

function toSUn(L, X)    -- Project a matrix onto SU(N)
  local Y = (X - X:adjoin()) / 2    -- anti-hermitian part
  return (Y - Y:trace() / Nc * L:ColorMatrix(complex(1, 0))):exp()
end

function weak_SUn(L, S)    -- Generate a SU(N) field close to 1
  return toSUn(L, .1 * S:gaussian_ColorMatrix())
end

function weakSingleSUn()
  return toSUnSingle(.1 * qcd.ColorMatrix())    -- need an analog of S:gaussian_ColorMatrix
end

function strong_SUn(L, S)
  local v = weak_SUn(L, S)
  for i = 1, 100 do -- multiply a lot of small SU(n) matrices, then re project
    v = v * weak_SUn(L, S)
  end
  return v:proj(1e-6, 150)
end

function plaquette(U, i, j)   -- U is the gauge field configuration, i = \hat{\mu}, j = \hat{\nu}
  local Ui = U[j + 1]:shift(i, "from_forward")
  local Uj = U[i + 1]:shift(j, "from_forward")
  local Pij = (U[i + 1] * Ui * Uj:adjoin() * U[j + 1]:adjoin()):trace():real()
  return Pij:sum() / (vol * Nc)
end

--[[ TODO what is the most efficient way to do this?
Returns the staple field from deleting the link variable in the mu direction
]]
function getStaples(U, mu)
  staples = L:ColorMatrixN(Nc, 0.0)
  for nu = 0, #L - 1 do
    if nu ~= mu then
      local UMu = U[nu + 1]:shift(mu, "from_forward")
      local UNu = U[mu + 1]:shift(nu, "from_forward")
      local UMuNu = U[nu + 1]:shift(mu, "from_forward"):shift(nu, "from_backward")
      local UNegNuMu = U[mu + 1]:shift(nu, "from_backward")
      local UNegNuNu = U[nu + 1]:shift(nu, "from_backward")
      staples = staples + (UMu * UNu:adjoin() * U[nu + 1]:adjoin()
          + UMuNu:adjoin() * UNegNuMu:adjoin() * UNegNuNu)
    end
  end
  return staples
end

-- returns the staple in the mu direction at site (x, y, z, t)
function getStaple(U, mu, x, y, z, t)
  return getStaples(U, mu)[{x, y, z, t}]
end

-- Construct random gauge field
function getRandomColorMatrix(L, S)
  U = {}
  for i = 0, #L - 1 do
    U[i + 1] = toSUn(.3 * S:gaussian_ColorMatrix())
  end
  return U
end

function show_color_mat(U)
  local Nc = U:colors()
  for a = 0, Nc-1 do
    for b = 0, Nc-1 do
      local elt = U[{a=a,b=b}]
      printf("%.6f %+.6f\t", elt:real(), elt:imag())
    end
    printf("\n")
  end
end

function computeLocalDeltaS(U, UPrimeMu, mu, x, y, z, t, Nc)
  beta = 5.7
  dU = UPrimeMu[{x, y, z, t}] - U[mu + 1][{x, y, z, t}]
  return (-1) * beta / Nc * (dU * getStaple(U, mu, x, y, z, t)):trace():real()
end

function init_zero_field(L, Nc, U)
  for mu = 0, #L - 1 do
    local A = L:ColorMatrixN(Nc, 0.0)
    U[mu+1] = (A*complex(0,1)):exp()
  end
end

function write_to_file(filename, n, C)
  file = io.open(filename, "a")
  file:write(string.format("%d | %s\n", n, C))
  file:close()
end

function read_gauge(filename, Lx, Lt, Nd, Nc, U, imag)
  local counter = 0
  local x, y, z, t, mu, a, b
  for line in io.lines(filename) do
    local temp = counter
    local value = tonumber(line)
    b = temp % Nc
    temp = temp - b
    temp = temp / Nc
    a = temp % Nc
    temp = temp - a
    temp = temp / Nc
    x = temp % Lx
    temp = temp - x
    temp = temp / Lx
    y = temp % Lx
    temp = temp - y
    temp = temp / Lx
    z = temp % Lx
    temp = temp - z
    temp = temp / Lx
    t = temp % Lt
    temp = temp - t
    temp = temp / Lt
    mu = temp
    -- if temp >= Nd, this is bad
    -- if temp >= Nd then printf("%d\n", counter) end
    assert (temp < Nd)
    local comp_value
    if imag then
      comp_value = complex(0, value)
    else
      comp_value = complex(value, 0)
    end
    U[mu+1][{x,y,z,t,a=a,b=b}] = U[mu+1][{x,y,z,t,a=a,b=b}] + comp_value
    counter = counter + 1
  end
end

-- Initialize gauge field from HMC run.
function initGaugeField(L, Nc, U)
  local configNum = 0    -- check cfgbase folder to see how many configs available
  local cfgbase = "su3_w_b5.70_N5_skip10_therm100_4_4_4_8"
  local filename_real = string.format("%s/%s_realconfig%d.txt", cfgbase, cfgbase, configNum)
  local filename_imag = string.format("%s/%s_imagconfig%d.txt", cfgbase, cfgbase, configNum)

  init_zero_field(L, Nc, U)
  printf("Reading from: %s\n", filename_real)
  read_gauge(filename_real, L[0], L[3], #L, Nc, U, false)
  printf("Reading from: %s\n", filename_imag)
  read_gauge(filename_imag, L[0], L[3], #L, Nc, U, true)
end

-- computes the pion interpolator for a single configuration of gauge field U.
function computePionInterpolator(L, U, n_t)
  -- Hopping parameters
  m_u = 2   -- in MeV-- what units should I use here?
  m_d = 4.8
  kappa_u = 1 / (2 * m_u + 8)
  kappa_d = 1 / (2 * m_d + 8)
  kappa = .071    -- generic hopping parameter

  -- Construct propagators. Need the inverse of the Dirac operator, so will
     -- use solvers, which the Clover object contains.
  c_sw = 1.0      -- Sheikholeslami-Wohlert coefficient for clover term
  bc = {1, 1, 1, -1}    -- periodic in space, antiperiodic in time

  CL_u = qcd.Clover(U, kappa_u, c_sw, bc)
  solveU = CL_u:solver(1e-10, 1000, 1e-25, 2000)

  CL_d = qcd.Clover(U, kappa_d, c_sw, bc)
  solveD = CL_d:solver(1e-10, 1000, 1e-25, 2000)

  -- TODO figure out how to put a sink at {0, 0, 0, n_t}
  src = L:DiracPropagator()
  Nc = src:colors()
  for ic = 0, Nc - 1 do -- loop over color indices
    for is = 0, qcd.Ns - 1 do  -- loop over spinor indices
      local dv = L:DiracFermion()
      dv[{0, 0, 0, 0, c = ic, d = is}] = complex(1, 0)
      dv[{0, 0, 0, n_t, c = ic, d = is}] = complex(1, 0)    -- TODO is this right?
      src[{c = ic, d = is}] = dv
    end
  end

  uProp = solveU(src)  -- D_u(n|m)^-1
  dProp = solveD(src)  -- D_d(n^m)^-1

  return (-1) * (uProp * dProp:conj()):spintrace():trace():sum()
end

------------------------------------------------------------------
-------------------------- BEGIN SCRIPT --------------------------
------------------------------------------------------------------

L = qcd.lattice{4, 4, 4, 8}
volume = 1
for i = 0, #L - 1 do
  volume = volume * L[i]
end
Nc = 3    -- qcd.Nc

-- random generator used to create gauge field
r = { }
do
  r.x = os.random()
  local x = L:Int(r.x)
  for i = 0, #L - 1 do
    r[i+1] = os.random()
    x = x * L[i] + L:pcoord(i) * r[i+1]
  end
  r.f = os.random()
  S = L:RandomState(r.f, x)
end

U = {}
initGaugeField(L, Nc, U)

n_t = 4    -- Number of links in t dimension to compute Wilson loop
C = 0    -- sum up value of <...> for all gauge field configs
nItr = 1  -- Do 10
nSweep = 10    -- how many times to update each lattice site per sweep
nMeasured = 0    -- number of running measurements
beta = 5.7  -- Get it from the file name
for i = 0, nItr do
  for mu = 0, #L - 1 do
    -- initialize weak color matrix field
    --[[
    X = weak_SUn(L, S)    -- Random color matrix field
    UPrimeMu = U[mu + 1] * X    -- evaluated at every lattice point
    --]]
    for x = 0, L[0] - 1 do
      for y = 0, L[1] - 1 do
        for z = 0, L[2] - 1 do
          for t = 0, L[3] - 1 do
            -- screen the update to see if we should keep it
            local A = getStaple(U, mu, x, y, z, t)
            local X = weak_SUn(L, S)
            --[[ TODO: how do you generate a single color matrix and not an
            entire field of matrices? Right now I'm generating X as a color matrix
            field and picking its elements, it seems very inefficient though. ]]
            for k = 0, nSweep do
              --literally just pick a matrix out of the matrix field
              local r = math.random()
              if k < L[0] then coord = {k, 0, 0, 0} else coord = {0, 0, 0, k - L[0] + 1} end
              local X1 = X[coord]
              local U1 = U[mu + 1][{x, y, z, t}]
              local UPrimeMu = X1 * U1
              local dU = UPrimeMu - U1
              local dS = (-1) * beta / Nc * (dU * A):trace():real()

              if r < math.exp(dS) then
                U[mu + 1][{x, y, z, t}] = UPrimeMu
              end
            end
            --[[
            for k = 0, nSweep do
              r = math.random()
              dS = computeLocalDeltaS(U, UPrimeMu, mu, x, y, z, t, Nc)
              if dS < r then
                U[mu + 1][{x, y, z, t}] = UPrimeMu[{x, y, z, t}]
              end
            end
            --]]
          end
        end
      end
    end
    -- change placement based on how often we want to measure the configuration.
    -- at some point can use autocorrelation to determine if we've swept enough.
    nMeasured = nMeasured + 1
    C = C + computePionInterpolator(L, U, n_t)
    printf("Average C is: %s\n", tostring(C / nMeasured))
  end
end

--C = C + computeInterpolator(L, U)
if nMeasured == 0 then nMeasured = 1 end
CAvg = C / nMeasured

printf("Interpolator evaluates to: %s\n", tostring(CAvg))

folder = "mass_test"
file_base = "4_4_4_8"
filename = string.format("%s/%s.txt", folder, file_base)
write_to_file(filename, n_t, tostring(CAvg))
printf("File written to: %s\n", filename)
