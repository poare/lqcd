require "stdlib"

P_L = (1 - gamma{mu = 5}) / 2
printf("Left projector = %s\n", tostring(P_L))

-- initialize lattice size
L = qcd.lattice{4, 4, 4, 4}
printf("Lattice rank=%d\n", #L)
for i = 0, #L - 1 do
  printf("Dimension %d has %d lattice points\n", i, L[i])
end

vol = 1    -- compute volume of lattice
for i = 0, #L - 2 do
  vol = vol * L[i]
end
hypervolume = vol * L[#L - 1]

-- initialize random object generator on the lattice
do
  local r = L:Int(os.random())
  for i = 0, #L - 1 do
    r = r * L[i] + L:pcoord(i)
  end
  S = L:RandomState(os.random(), r)
end

Nc = 3    -- Nc = qcd.Nc

function toSUn(L, X)    -- Project a matrix onto SU(N)
  local Y = (X - X:adjoin()) / 2    -- anti-hermitian part
  return (Y - Y:trace() / Nc * L:ColorMatrix(complex(1, 0))):exp()
end

function weak_SUn(L, S)    -- Generate a SU(N) matrix close to 1
  return toSUn(L, .1 * S:gaussian_ColorMatrix())
end

function strong_SUn(L, S)
  local v = weak_SUn(L, S)
  for i = 1, 100 do -- multiply a lot of small SU(n) matrices, then re project
    v = v * weak_SUn(L, S)
  end
  return v:proj(1e-6, 150)
end

function plaquette(U, i, j)   -- U is the gauge field configuration, i = \hat{\mu}, j = \hat{\nu}
  -- always index at i + 1 or j + 1 because i, j are from 0 to #L - 1, while U indexes from
  -- 1 to #L (so U_1 = U_x, U_2 = U_y, U_3 = U_t for 3-dim)
  local Ui = U[j + 1]:shift(i, "from_forward")  -- Shifts to U(n + \hat{\mu})
  local Uj = U[i + 1]:shift(j, "from_forward")  -- Shifts to U(n + \hat{\nu})
  local Pij = (U[i + 1] * Ui * Uj:adjoin() * U[j + 1]:adjoin()):trace():real()
  -- Pij = trace(U_\mu\nu), U_\mu\nu = U_\mu(n) U_\nu(n + \mu) U_\mu(n + \nu)^\dagger U_\nu(n)^\dagger
  -- Note the correspondences here:
  -- \mu <--> i + 1, \nu <--> j + 1
  -- U_\mu(n) <--> U[i + 1] (because \mu <--> i + 1, and not shifting leaves the field at n)
  -- U_\nu(n + \mu) <--> Ui (because we have shifted it in the i (\mu) direction and indexed at \nu <--> j + 1)
  -- U_\mu(n + \nu)^\dagger <--> Uj:adjoin()
  -- U_\nu(n)^\dagger <--> U[j + 1]:adjoin()
  return Pij:sum() / (vol * Nc)
end

function run_test(name, U)
  printf("plaquette test case: %s\n", name)
  local s = 0
  local k = 0
  for i in interval(0, #L-1) do    -- index over all directions on the lattice
    for j in skip(i, interval(0, #L-1)) do    -- don't index over i, because \mu\neq\nu
      local sij = plaquette(U, i, j)
      printf("  plaq[%d, %d] = %20.10f\n", i, j, sij)
      s = s + sij
      k = k + 1
    end
  end
  printf("average plaquette %20.10f\n\n", s / k);
end

-- run for a weak gauge field
W = {}
for i = 0, #L - 1 do    -- #L = 2 for a 3 dim lattice
  W[i+1] = weak_SUn(L, S)
end
run_test("weak field", W)

-- Structure of gauge field object U:
-- U[i + 1] gets the color matrix on the link in direction \mu = i + 1
-- By default, U[i + 1] will only get you the value of the field on the links attached
    -- to the site you are at, i.e. only U_\mu(n). You can change \mu but not n.
-- To move to a different site to access its link variables, you can
    -- use U[i + 1]:shift(j, "from_forward"). The from_forward will shift you a site
    -- over in the \nu = j + 1 direction.

printf("%d\n", #L)    -- W[1], W[2], W[3] has color matrices

printf("%d\n", qcd.Ns)    -- qcd.Ns = number of spinor indices.

function show_color_mat(U)
  local Nc = U:colors()
  for a = 0, Nc-1 do
    for b = 0, Nc-1 do
      local elt = U[{a=a,b=b}]
      printf("%.6f %+.6f\t", elt:real(), elt:imag())
    end
    printf("\n")
  end
end

staples = L:ColorMatrixN(Nc, 0.0)
printf("\n\n")

show_color_mat(staples[{0, 0, 0, 0}])

field = L:pcoord(3)
n_t = 3
-- want to sum spatial components of field on the n_t timeslice.
summed = field:sum(L:MultiSet(L[3], L:pcoord(3)))
print(summed[n_t])   -- should be vol * n_t

function old_code()
  n_t = 4    -- Number of links in t dimension to compute Wilson loop
  C = 0    -- sum up value of <...> for all gauge field configs
  nItr = 1  -- Do 10
  nSweep = 10    -- how many times to update each lattice site per sweep
  nMeasured = 0    -- number of running measurements
  beta = 5.7  -- Get it from the file name
  for i = 0, nItr do
    for mu = 0, #L - 1 do
      -- initialize weak color matrix field
      --[[
      X = weak_SUn(L, S)    -- Random color matrix field
      UPrimeMu = U[mu + 1] * X    -- evaluated at every lattice point
      --]]
      for x = 0, L[0] - 1 do
        for y = 0, L[1] - 1 do
          for z = 0, L[2] - 1 do
            for t = 0, L[3] - 1 do
              -- screen the update to see if we should keep it
              local A = getStaple(U, mu, x, y, z, t)
              local X = weak_SUn(L, S)
              --[[ TODO: how do you generate a single color matrix and not an
              entire field of matrices? Right now I'm generating X as a color matrix
              field and picking its elements, it seems very inefficient though. ]]
              for k = 0, nSweep do
                --literally just pick a matrix out of the matrix field
                local r = math.random()
                if k < L[0] then coord = {k, 0, 0, 0} else coord = {0, 0, 0, k - L[0] + 1} end
                local X1 = X[coord]
                local U1 = U[mu + 1][{x, y, z, t}]
                local UPrimeMu = X1 * U1
                local dU = UPrimeMu - U1
                local dS = (-1) * beta / Nc * (dU * A):trace():real()

                if r < math.exp(dS) then
                  U[mu + 1][{x, y, z, t}] = UPrimeMu
                end
              end
              --[[
              for k = 0, nSweep do
                r = math.random()
                dS = computeLocalDeltaS(U, UPrimeMu, mu, x, y, z, t, Nc)
                if dS < r then
                  U[mu + 1][{x, y, z, t}] = UPrimeMu[{x, y, z, t}]
                end
              end
              --]]
            end
          end
        end
      end
end
