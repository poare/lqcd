#!/usr/bin/env qlua

require "stdlib"
require "lib/fermion"
require "lib/clover_ferm"
require "lib/group"
require "lib/musing"
require "lib/propagator"
require "lib/su-n"

-------------------------------------------------------------------
------------------------ UTILITY FUNCTIONS ------------------------
-------------------------------------------------------------------

function initGaugeFieldLime(L, file)
  reader, rinfo = qcd.qdpc.Reader(L, file)
  U, uInfo = reader:ColorMatrix(#L)
  return U
end

function random_state_generator(L)
  local r = L:Int(os.random())
  for i = 0, #L - 1 do
    r = r * L[i] + L:pcoord(i)
  end
  local S = L:RandomState(os.random(), r)
  return S
end

-- Projects random 3 by 3 matrix X onto SUn
function toSUn(L, X)
  Nc = 3
  local Y = (X - X:adjoin()) / 2
  return (Y - Y:trace() / Nc * L:ColorMatrix(complex(1,0))):exp()
end

function weak_SUn(L, S)
  return toSUn(L, 0.2 * S:gaussian_ColorMatrix())
end

function random_SUn_field(L)
  local S = random_state_generator(L)
  local v = weak_SUn(L, S)
  for i = 1, 100 do
    v = v * weak_SUn(L, S)
  end
  return v:proj(1e-6, 150)
end

-- Performs gauge transformation \Omega on gauge field U. This is the transformation
--  U_\mu(n)\mapsto \Omega(n) U_\mu(n) \Omega(n + \hat{mu}) (eqn 3.6)
function gauge_transform(L, U, omega)
  local Uprime = {}
    for mu = 0, #L - 1 do
      Uprime[mu + 1] = omega * U[mu + 1] * omega:shift(mu, "from_forward"):adjoin()
    end
  return Uprime
end

function compute_npr(L, U, ferm_prop, p_list, hypervolume, L_mom, clover, writer, cfgnum)
  local bvec = {0,0,0,0.5}

  for pidx = 1, #p_list do
    printf("p index: %d\n", pidx)
    local p = p_list[pidx]
    printf("Momentum is (%d, %d, %d, %d).", p[1], p[2], p[3], p[4])
    local FTarg = L:Real(0)
    for mu = 0, #L - 1 do
      FTarg = FTarg + L:Real(L:pcoord(mu)) * (p[mu + 1] + bvec[mu + 1]) * 2 * math.pi / L[mu]
    end
    local FT = FTarg:expi()

    -- what does spacetime_wall_source do? Source with definite momentum?
    -- TODO should I compute with a point source since I know how to do that?
    local src = compute_spacetime_wall_source_antiperiodicBC(U, p)
    local prop = compute_propagator(U, ferm_prop, src)    -- S(x, y)
    local anti_prop = gamma{mu = 5} * prop:adjoin() * gamma{mu = 5}
    local mom4_prop = (FT * prop):sum()    -- this is S(p)

    -- Write momentum projected propagator to file (?)
    local prop_path = string.format("prop/p%d%d%d%d/cfg%d", p[1], p[2], p[3], p[4], cfgnum)
    h5_force_write(writer, prop_path, mom4_prop)
    printf("Propagator written at path: %s\n", prop_path)

    -- Test  correct by performing a gauge transformation.
    -- TODO if this still doesn't work then use "from_backward" in the shift
    print("Computing observables after gauge transformation.")
    -- local omega = random_SUn_field(L)
    local S = random_state_generator(L)
    local omega = SUn.randomAlgebra(S, 3):expi()
    local Uprime = gauge_transform(L, U, omega)
    local srcprime = compute_spacetime_wall_source_antiperiodicBC(Uprime, p)
    local propprime = compute_propagator(Uprime, ferm_prop, srcprime)
    local mom4_prop_prime = (FT * propprime):sum()
    local prop_prime_path = string.format("propprime/p%d%d%d%d/cfg%d", p[1], p[2], p[3], p[4], cfgnum)
    h5_force_write(writer, prop_prime_path, mom4_prop_prime)

    -- Currently assuming that the prop that I compute is S_p(z). Need to confirm this.

    -- compute momentum projected Green's function G(p)
    -- TODO the object prop is the two point propagator S(x, y)
    local norm = 1 / (2 * math.sqrt(2) * hypervolume)
    local JS33 = U[4] * (gamma{mu = 3} * prop:shift(3, "from_forward")) + U[4]:shift(3, "from_backward"):adjoin() *
            (gamma{mu = 3} * prop:shift(3, "from_backward")) - 2 * gamma{mu = 3} * prop
    -- TODO is the mu = 4 index time?
    local JS44 = U[1] * (gamma{mu = 0} * prop:shift(0, "from_forward"))  + U[1]:shift(0, "from_backward"):adjoin() *
            (gamma{mu = 0} * prop:shift(0, "from_backward")) - 2 * gamma{mu = 0} * prop
    local JS = JS33 - JS44        -- JS = \sum_z' J(z, z') S(z'), S is the propagator
    local G = norm * ( gamma{mu = 5} * prop:adjoin() * gamma{mu = 5} * JS ):sum()

    local threept_path = string.format("threept/p%d%d%d%d/cfg%d", p[1], p[2], p[3], p[4], cfgnum)
    h5_force_write(writer, threept_path, G)
    printf("Three point function written at: %s\n", threept_path)

    -- prop should be S(z, p) = \sum_x S(z, x) e^{ipx}, where $S$ is the propagator.

    -- Here down is done in the Python script.
    -- invert prop to amputate vertex function legs
    -- Amputate legs to get vertex function \Gamma(p)
    -- Compute quark field renormalization
    -- Compute \Gamma_{Born}(p)
    -- Compute operator renormalization Z(p)
  end
end

------------------------------------------------------------------
-------------------------- BEGIN SCRIPT --------------------------
------------------------------------------------------------------

-- Read in input from bash script.
if jobid and cfgpath and cfgbase then
    printf("Job ID: %d.\nEvaluating configurations at: %s%s.\n", jobid, cfgpath, cfgbase)
else
    print("No jobid, cfgpath, cfgbase entered.")
end

-- Uncomment to run test locally
-- jobid = 0
-- cfgpath = "/Users/poare/lqcd/npr_momfrac/testing/"
-- cfgbase = "cl3_16_48_b6p1_m0p2450"
-- cfgnum = 200
-- printf("Running test configuration.")

-- Set parameters
Lx = 16
Lt = 48
beta = 6.1
mq = 0.2450
kappa = 1 / (2 * mq + 8)
Nc = 3    -- qcd.Nc
L = qcd.lattice{Lx, Lx, Lx, Lt}
L_mom = qcd.lattice{Lt}
lqcd_dir = "/home/poare"    -- specify what the file path to lqcd is

volume = 1    -- spatial volume
for i = 0, #L - 2 do
  volume = volume * L[i]
end
hypervolume = volume * L[3]

-- Paths to output file.
folder = string.format("%s/lqcd/npr_momfrac/output", lqcd_dir)
out_folder = string.format("%s/%s_%d", folder, cfgbase, jobid)
filename = string.format("%s/cfg%d.h5", out_folder, cfgnum)
printf("OUTPUT FILE WILL WRITE TO: %s\n", filename)

local csw = 1
local bcs = {1,1,1,-1}
local clover = clover_ferm.cpu_4d_nc3(kappa, csw, bcs)
local ferm_prop = propagator.make_from_ferm(clover, 1e-20, 1000)

-- momenta to compute Z(p) at
-- local p_list_NPR = {{2,2,2,2},{2,2,2,4},{2,2,2,6},{3,3,3,2},{3,3,3,4},{3,3,3,6},{3,3,3,8},{4,4,4,4},{4,4,4,6},{4,4,4,8}}
local p_list_NPR = {{2, 2, 2, 2}}

gauge_file = string.format(cfgpath..cfgbase.."/cfgs/"..cfgbase.."_cfg_%d.lime", cfgnum)
print("Reading gauge file at: %s\n", gauge_file)

status, U, finfo, info = pcall(load_conf, L, gauge_file)
if status then
  -- Open file writer
  local hdf5params = { method = "phdf5" }
  local writer = qcd.hdf5.Writer(filename, hdf5params)

  print("Gauge file read. Computing NPR.")
  compute_npr(L, U, ferm_prop, p_list_NPR, hypervolume, L_mom, clover, writer, cfgnum)

  writer:close()
else
  printf("No gauge field configuration at %s.\n", gauge_file)
  logs_dir = string.format("%s/lqcd/npr_momfrac/logs/%s_%d", lqcd_dir, cfgbase, jobid)
  os.execute(string.format("mv %s/cfg%d.txt %s/no_output", logs_dir, cfgnum, logs_dir))
  print(U)
end
